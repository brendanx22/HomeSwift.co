/* sw.js — HomeSwift (Production-ready)
   Requirements:
   - A build step (Vite plugin) writes an up-to-date /sw-assets.json to your public/ folder.
   - Serve sw.js from the app root so scope covers all routes.
*/

const CACHE_VERSION = "v2.0.0"; // bump this for big changes or force-clear caches
const STATIC_CACHE = `homeswift-static-${CACHE_VERSION}`;
const DYNAMIC_CACHE = `homeswift-dynamic-${CACHE_VERSION}`;
const DYNAMIC_CACHE_MAX_ITEMS = 80;

// --- Helpers -----------------------------------------------------------------

// Trim cache to max items (oldest-first)
async function trimCache(cacheName, maxItems) {
  try {
    const cache = await caches.open(cacheName);
    const keys = await cache.keys();
    if (keys.length > maxItems) {
      await cache.delete(keys[0]);
      // recursive trim until under limit
      await trimCache(cacheName, maxItems);
    }
  } catch (err) {
    console.warn("[SW] trimCache error", err);
  }
}

// Determine navigation request
function isNavigationRequest(request) {
  return (
    request.mode === "navigate" ||
    request.destination === "document" ||
    (request.headers &&
      (request.headers.get("accept") || "").includes("text/html"))
  );
}

// Load asset list generated by Vite plugin at build time
async function loadStaticAssets() {
  try {
    const res = await fetch("/sw-assets.json", { cache: "no-store" });
    if (!res.ok) throw new Error("sw-assets.json fetch failed");
    const assets = await res.json();
    // Normalize entries to ensure leading slash
    return Array.isArray(assets)
      ? assets.map((a) => (a.startsWith("/") ? a : "/" + a))
      : ["/"];
  } catch (err) {
    console.warn(
      "[SW] Could not load sw-assets.json, falling back to defaults",
      err
    );
    return [
      "/",
      "/index.html",
      "/manifest.json",
      "/favicon.ico",
      "/logo192.png",
      "/logo512.png",
    ];
  }
}

// Minimal HTML offline page returned for navigation when cache is missing
function offlineHtmlResponse() {
  return new Response(
    `<!doctype html>
     <html lang="en">
       <head>
         <meta charset="utf-8"/>
         <meta name="viewport" content="width=device-width,initial-scale=1"/>
         <title>HomeSwift - Offline</title>
         <style>
           body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;display:flex;align-items:center;justify-content:center;height:100vh;margin:0;background:#0f172a;color:#e6eef8}
           .card{max-width:520px;padding:2rem;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));text-align:center}
           button{margin-top:1rem;padding:.6rem 1rem;border-radius:8px;border:0;cursor:pointer}
         </style>
       </head>
       <body>
         <div class="card">
           <h1>You’re offline</h1>
           <p>HomeSwift needs a network connection to load. Check your connection and try again.</p>
           <button onclick="location.reload()">Try again</button>
         </div>
       </body>
     </html>`,
    { headers: { "Content-Type": "text/html" } }
  );
}

// --- Install ----------------------------------------------------------------
self.addEventListener("install", (event) => {
  console.log("[SW] install");
  event.waitUntil(
    (async () => {
      try {
        const cache = await caches.open(STATIC_CACHE);
        const assets = await loadStaticAssets();

        // ensure some core files are included
        const core = ["/", "/index.html", "/manifest.json"];
        const uniqueAssets = Array.from(new Set([...assets, ...core]));

        // Attempt to add all; continue even if some fail
        await Promise.all(
          uniqueAssets.map(async (url) => {
            try {
              // use Request with no-cache when fetching to avoid stale sw-assets issues
              const req = new Request(url, {
                cache: "no-store",
                mode: "same-origin",
              });
              const res = await fetch(req);
              if (res && res.ok) {
                await cache.put(url, res.clone());
              } else {
                // as fallback: try cache.add (may fail for opaque)
                try {
                  await cache.add(url);
                } catch (e) {
                  /* skip silently */
                }
              }
            } catch (e) {
              // don't fail install because of one bad asset
              console.warn("[SW] Failed to precache", url, e);
            }
          })
        );

        console.log("[SW] install: static precache complete");
      } catch (err) {
        console.error("[SW] install error", err);
      } finally {
        // Activate worker as soon as it's finished installing
        await self.skipWaiting();
      }
    })()
  );
});

// --- Activate ---------------------------------------------------------------
self.addEventListener("activate", (event) => {
  console.log("[SW] activate");
  event.waitUntil(
    (async () => {
      // remove old caches that don't match current version
      const keys = await caches.keys();
      await Promise.all(
        keys
          .filter(
            (name) =>
              name.startsWith("homeswift-") && !name.includes(CACHE_VERSION)
          )
          .map((name) => {
            console.log("[SW] deleting old cache", name);
            return caches.delete(name);
          })
      );
      // take control immediately
      if (self.clients && self.clients.claim) {
        await self.clients.claim();
      }
    })()
  );
});

// --- Fetch ---------------------------------------------------------------
self.addEventListener("fetch", (event) => {
  const { request } = event;

  // Only handle GET over http(s)
  if (request.method !== "GET" || !request.url.startsWith("http")) return;

  const url = new URL(request.url);

  // Bypass cross-origin requests (APIs, CDNs) to avoid auth/session issues.
  if (url.origin !== location.origin) return;

  // Navigation requests (HTML) --> network-first with fallback to cached index/offline
  if (isNavigationRequest(request)) {
    event.respondWith(
      (async () => {
        try {
          const networkResponse = await fetch(request);
          // Optionally cache HTML responses if you want
          return networkResponse;
        } catch (err) {
          // return cached index or offline html
          const cache = await caches.open(STATIC_CACHE);
          const cached =
            (await cache.match("/")) || (await cache.match("/index.html"));
          if (cached) return cached;
          return offlineHtmlResponse();
        }
      })()
    );
    return;
  }

  // For static assets (same origin) -> cache-first, then network, and cache dynamically
  event.respondWith(
    (async () => {
      const cache = await caches.open(STATIC_CACHE);
      const cachedResponse = await cache.match(request);
      if (cachedResponse) return cachedResponse;

      // Not in static cache -> check dynamic cache
      const dynCache = await caches.open(DYNAMIC_CACHE);
      const dynCached = await dynCache.match(request);
      if (dynCached) return dynCached;

      try {
        const networkResponse = await fetch(request);
        // only cache successful responses
        if (networkResponse && networkResponse.status === 200) {
          // clone and store in dynamic cache
          const clone = networkResponse.clone();
          dynCache.put(request, clone).then(() => {
            trimCache(DYNAMIC_CACHE, DYNAMIC_CACHE_MAX_ITEMS).catch(() => {});
          });
        }
        return networkResponse;
      } catch (err) {
        // fetch failed -> fallback for images or throw
        if (request.destination === "image") {
          // tiny SVG placeholder
          return new Response(
            `<svg xmlns="http://www.w3.org/2000/svg" width="400" height="300"><rect width="100%" height="100%" fill="#f3f4f6"/><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="#9ca3af" font-size="20">Image offline</text></svg>`,
            { headers: { "Content-Type": "image/svg+xml" } }
          );
        }
        throw err;
      }
    })()
  );
});

// --- Background Sync (scaffold) --------------------------------------------
self.addEventListener("sync", (event) => {
  console.log("[SW] sync event", event.tag);
  if (event.tag === "background-sync") {
    event.waitUntil(
      (async () => {
        // Implement replay/flush logic (e.g., re-send queued requests from IDB)
        console.log(
          "[SW] background-sync placeholder — implement queue replay here"
        );
      })()
    );
  }
});

// --- Push Notifications ----------------------------------------------------
self.addEventListener("push", (event) => {
  console.log("[SW] push received");
  let data = {
    title: "HomeSwift",
    body: "You have a new notification",
    url: "/",
  };
  try {
    if (event.data) {
      data = event.data.json();
    }
  } catch (e) {
    // If it's not JSON, use text()
    try {
      data.body = event.data.text();
    } catch (_) {}
  }

  const title = data.title || "HomeSwift";
  const options = {
    body: data.body || "",
    icon: data.icon || "/logo192.png",
    badge: data.badge || "/favicon.ico",
    data: { url: data.url || "/", timestamp: Date.now() },
    actions: data.actions || [{ action: "open", title: "Open" }],
  };

  event.waitUntil(self.registration.showNotification(title, options));
});

// --- Notification click handling ------------------------------------------
self.addEventListener("notificationclick", (event) => {
  event.notification.close();
  const targetUrl =
    (event.notification.data && event.notification.data.url) || "/";
  event.waitUntil(
    (async () => {
      const allClients = await clients.matchAll({
        type: "window",
        includeUncontrolled: true,
      });
      for (const c of allClients) {
        // if a client already has the URL open, focus it
        if (c.url === targetUrl && "focus" in c) {
          return c.focus();
        }
      }
      // otherwise open a new window/tab
      if (clients.openWindow) return clients.openWindow(targetUrl);
    })()
  );
});

// --- Message handler (for update flow) ------------------------------------
self.addEventListener("message", (event) => {
  if (!event.data) return;
  if (event.data.type === "SKIP_WAITING") {
    // activate new SW immediately
    self.skipWaiting();
  }
});
